(this.webpackJsonpreact_report=this.webpackJsonpreact_report||[]).push([[0],{23:function(e,t,r){},24:function(e,t,r){},52:function(e,t,r){"use strict";r.r(t);var i=r(1),a=r.n(i),s=r(9),n=r.n(s),o=(r(23),r(24),r(11)),c=r(2),h=r(15),l=r(10),d=r.n(l),j=r(0),p=r(47);var m=function(){return Object(j.jsxs)("div",{children:[Object(j.jsx)(o.a,{bg:"dark",variant:"dark",class:"shadow p-3 mb-5 bg-body rounded",children:Object(j.jsx)(o.a.Brand,{children:Object(j.jsx)("h2",{children:"3D Interactive Fluid Simulation Report"})})}),Object(j.jsxs)(h.a,{children:[Object(j.jsx)(c.a,{children:Object(j.jsx)(o.a.Brand,{children:Object(j.jsx)("h4",{children:"Vikranth Srivatsa, Bhuvan Basireddy, Kevin Lo, Benjamin Cheung"})})}),Object(j.jsx)("img",{src:"logo.png",class:"center"})]}),Object(j.jsx)("br",{}),Object(j.jsxs)(h.a,{children:[Object(j.jsx)(c.a,{children:Object(j.jsx)("h2",{children:"Abstract"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"Fluid simulations such as those with water, fire, smoke are very important in realtime games and visual effects. The many realistic water mods from games such as Skyrim and Minecraft provide a strong case study of their usability. Particle simulation among other approaches is popular method of simulating these effects. The study of these simulations particle simulations is usually based around Navier-Stokes fluid dynamics equations. Smoothed Particle Simulation is a method to extend these equations. The paper Particle-Based FluidSimulation for Interactive Applications presents an approach to approximate these interactions. We extend and attempt to replicate this project, while adding providing an interactive realtime demo for others to extend."})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h2",{children:"Motivations"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"There were previous semesters of CS184 that presented fluid simulation. These fluid simulations were usually 2D, which greatly reduced the complexity, and pre-rendered for their demonstration. However, for popular games and visual effects, these environment is 3D and close to realtime and not pre-rendered. This greatly increases the complexity and computational requirements to render. The project is our attempt at creating this realtime effect with a large number of 3D particles with user interactions."})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h2",{children:"Technical approach"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"The project was implemented C++ and OpenGL for speed and performance. The sections below describe the technical approaches and advantages of our approaches"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h5",{children:"Initial Framework: Three.js"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"Three.js is a cross-browser library and API that can help developers create and display graphics using WebGL. It offers a lot of easy integrations into a scene such as options to specify where to place the camera, directional light, ambient light, etc. It also helps with applying shaders as they have several built-in including a Phong shader. Up to our project milestone, we had a working physics simulation for our particle system as well as a custom Blinn-Phong shader. During our test runs we noticed that performance was not addequate for realistic 3d fluid simulation. For a realistic simulation, the goal is to have at least 2,000 particles at a consistent framerate. As a reference, the paper we read uses 5,000 particles. Our simulations ran at very low frame rates: 100 particles ran at 45-60 fps and 300 particles ran at 1-3 fps. We considered the value of offloading computational logic to Golang using web assembly but after testing with it, web assembly didn't seem to provide the easy integration we sought. Thus, we decided that it may be faster to start over using C++."})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h5",{children:"Current Framework: C++ and OpenGL"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"After implementing in three.js, we wanted something that would perform well. C++ allows for closer native performance and compiler optimizations that would allow us to write real time applications. Thus, we transitioned to implementing the algorthim and logic from scratch in C++ and OpenGL. Transitioning to C++ had it's own learning curve in order to setup proper cross compilation and learning the OpenGL abstraction and interfaces. For the cross compilation, we took inspiration from cs184 p4-clothsim, but we had to modify it to use the faster glm vector library, open mp for threading, etc. The OpenGL abstractions were inspired from the tutorial series https://github.com/opengl-tutorials/ogl."})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"A good overview of framework is provided in the image below."})}),Object(j.jsxs)(c.a,{children:["    ",Object(j.jsx)("img",{src:"arch_diagram.jpg",class:"arch_diagram"})]}),Object(j.jsx)(c.a,{children:Object(j.jsx)("b",{children:"Rendering Loop and Logic"})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:["The general rendering loop followed initializing the window, the shaders, the textures, and repeatedly drawing updates to the rendering logic in a loop.",Object(j.jsx)("br",{}),Object(j.jsx)("br",{}),"To render the sphere, we used the stacks and slices approach to determine the vertices and normals as shown by https://www.songho.ca/opengl/gl_sphere.html. This involes iterates through different angles at ",Object(j.jsx)(p,{children:"$phi = \\frac{stack_{iteration}}{stacks} - .5) * .5 * PI$"})," and different ",Object(j.jsx)(p,{children:"$theta = (2 * PI * slice_iteration/slices)$"}),". Then, given those two angles we can use the spherical coordinates to derive the position of the vertices of the spheres. We compute the normals by normalizing these vector operations. By providing a single sphere with vertices to the shader, we can dramatically reduce the computation cost.",Object(j.jsx)("br",{}),Object(j.jsx)("br",{}),"In order to further reduce the computational cost, we use the idea of vertex indexing, which prevents repeated vertices from being sent to the shader when rendering the triangles that make up the sphere. We also draw and instatinate all particle positions all at once using glDrawElementsInstanced, which sends the data to the shader in a single mesh instead of multiple meshes, which significantly boosts rendering performance. For our implementation, we use 20 stacks and 20 slices. With some manual openGL binding, we are able to send these to shader and also render the relevant values.",Object(j.jsx)("br",{}),Object(j.jsx)("br",{}),"Another important aspect of rendering is using the correct proejection matrix to view the data. In order to setup the camera and projection matrices, we took inspiration from proj4-clothsim management of the camera.",Object(j.jsx)("br",{}),Object(j.jsx)("br",{}),"One aspect of rendering that optimized our binding is to manually bind open gl buffer and vertex attributes such as normals. In the proj4-clothsim code, nano-gui is used as an overhead layer for some of these operations, but we were able to use the optimal version of some of these functions in our code."]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h5",{children:"Simulation and Physics Logic"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:" The physics simulation was the most important and expensive part of rendering realistic the fluid. The simulation is based on Smoothed Particle Simulation."})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:[" For each particle, we compute the density for a single particle via ",Object(j.jsx)(p,{children:"$\\sum_j mass_j * W(r - r_j, h)$"}),"where W is a weight kernel and r is the vector distance of praticle. We discuss the different kernels later "]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:" Since the local density of each particle is differnet than the global density, we have to use a density function. For each of the particles, we then compute the forces that are applied to it. The relevant forces are surface tension, pressure, viscosity, gravity, and other external forces."})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:["To compute viscosity, we use the formula  ",Object(j.jsx)(p,{children:"$\\mu * \\sum_j * mass_j * \\frac{v_j - v_i}{density_j} * laplaceW(r_i - r_j, h)$"})]})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:[Object(j.jsx)(p,{children:"To compute pressure, $-\\sum_j * mass_j * \\frac{(density_i + density_j)}{(2 * density_j)} * \\nabla W(r_i, r_j)$"})," "]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:Object(j.jsx)(p,{children:"To compute surface tension, we compute $\\sigma * k * n = \\sigma * \\delta^2 * c_s * \\frac{n}{|n|}$ where c_s is $\\sum_{j} mass_j * \\frac{1}{density_j} * W(r - r_j, h)$ and $k = \\sum_{j} mass_j * \\frac{1}{density_j} * \\nabla^2 W(r - r_j, h)$"})})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:[" To compute gravity, we add the force ",Object(j.jsx)(p,{children:"$(0, -9.8, 0)$"})]})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:[" The weight kernels we used were the weight kernel with the parmaters r, h which are distance and kernel paramater.",Object(j.jsx)(p,{children:"$W_{poly6} = \\frac{315}{64 * pi * h^9} *((h^2 - r^2)^3 \\text{ if } 0 <= r <= h \\text{ else } 0)$"})," for everything except surface tension and viscosity. Kernel used for surface tension ",Object(j.jsx)(p,{children:"$W_{spiky} = \\frac{15}{pi * h^6} * ((h-r)^3 \\text{ if } 0 <= r <= h \\text{ else } 0)$"}),". Kernel used for viscosity ",Object(j.jsx)(p,{children:"$W_{viscosity} = \\frac{15}{2 * pi * h^3} * (-\\frac{r^3}{2*h^3} + \\frac{r^2}{h^2} + \\frac{h}{2*r} - 1 \\text{ if } 0 <= r <= h \\text{ else } 0)$"})]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:" To create user interaction, we took the mouse position and the detla formed with the mouse movement. Then computed the inverse of the camera and projection matrices. Then, we used cosine similairty to determinate which particles on the plane to apply the forces to. With a constant factor, we applied the force in the interaction. We apply the mouse force over multiple iterations."})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:[" Another interesting force we added is the whirlpool effect. This involved adding the force towards the center via ",Object(j.jsx)(p,{children:"$\\frac{mv^2}{r}$"}),"."]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"In order to update the position, we use an implicit euler approach and also use dampening when the water particles hit the walls"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h5",{children:"Optimizations"})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"We spent a lot of time optimizing our code since we wanted to achieve a large number of particles and similiar results to the paper we are referencing. We first used the valgrind profiling to track areas of the c++ code that required the most optimization. The physics simulation in our case was taking most of the time in serial fashion. We started by optimizing thsi code to take advantage of cache locality and using threads to run each particles computation in parallel. This provided a great speed up of 3-4x. In order to visualize our performance improvements, we added a FPS counter as part of our rendering logic. The next optimization was to realize that the operation of checking the forces that depend on a particle interaction with every other particle was n^2. However, the particles that mattered and applied the most important forces were close together. We needed to find a quick way to compute the neighbors of the particles in 3d space to find which particles for each particle affected it the most. We considered using OctoTrees and KDTrees, but we ended up using nanoflann since it had a fast open source implementation of finding neighbors. Even with the overhead of creating a new KDTree each loop, we were seeing another 3-4x improvement in the performance. Another optimization we did was to hardcode the constants instead of passing them in at runtime. We noticed a large speedup in our code due to the compiler being able to optimize the results. We used the compiler -O3 flat to build a performant release version of the code that does smart loop unrolling and other optimizations. After applying these optimizations, we were able to get a realtime simulation of 4000 particles at around 12-15 fps with 40 vertices per sphere. These results were on a Intel i5-4690K with an Nvidia GTX 3060."})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h5",{children:"Shaders"})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:["The implement the shaders we planned to apply a water texture to the surface. After adding some opengl bindings to pass the paramaters in, we passed the texture to the fagmeshader. In order to make the texture wrap around the sphere properly, we send proper uv coordinates to map the texture to the sphere. For each coordinate of the sphere we get the uv ",Object(j.jsx)(p,{children:"$(\\frac{phi}{(2*PI)}, \\frac{theta}{PI} + .5)$"}),"to prevent tearing of the texture. We also wanted the water to be reflective since water is naturally reflective. We used a combination of the mirror shader w0 as camera_pos - vertex_pos. Using the normal, we can compute the reflection as ",Object(j.jsx)(p,{children:"$w_i = w_0 - 2 *<w_0, n> * n$"}),". Then we just sample the texture at wi based on that result. Another interesting shader we rendered is the colorful shader that changes the color based on the camera angle. We instead first sample the texture then add the mirror direction wi to create the colorful shader."]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("h2",{children:"Results"})}),Object(j.jsx)(c.a,{children:Object(j.jsxs)("p",{children:["Simulation Params that we tweaked to make it more realistic water for our simulation is listed below.",Object(j.jsxs)("table",{children:[Object(j.jsxs)("tr",{children:[Object(j.jsx)("th",{children:"Paramater Name"}),Object(j.jsx)("th",{children:"Paramater Value"}),Object(j.jsx)("th",{children:"Paramater Description"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"h"}),Object(j.jsx)("td",{children:".5"}),Object(j.jsx)("td",{children:"Used in the physics kernel paramaters to determine the properties of water"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"surface tension sigma"}),Object(j.jsx)("td",{children:".00728"}),Object(j.jsx)("td",{children:"The surface tension constant applied as a multiplier to surface tension force"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"pressure rho zero"}),Object(j.jsx)("td",{children:"80"}),Object(j.jsx)("td",{children:"The default water pressure"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"The viscosity mu"}),Object(j.jsx)("td",{children:"1"}),Object(j.jsx)("td",{children:"Paramater for how viscous the water seems"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"Particle Initial Mass"}),Object(j.jsx)("td",{children:".0002"}),Object(j.jsx)("td",{children:"The initial mass of each particle, which drastically affects the simulation"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"KD Tree results to query "}),Object(j.jsx)("td",{children:"1/60"}),Object(j.jsx)("td",{children:"The number of nearest neighbor particles to query as an optimization"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"delta_t per simulation timestamp "}),Object(j.jsx)("td",{children:"1/60"}),Object(j.jsx)("td",{children:"Paramater for how viscous the water seems"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"Dampening"}),Object(j.jsx)("td",{children:".65"}),Object(j.jsx)("td",{children:"The dampening when a particle hits the wall"})]}),Object(j.jsxs)("tr",{children:[Object(j.jsx)("td",{children:"Num external force iterations"}),Object(j.jsx)("td",{children:"5"}),Object(j.jsx)("td",{children:"The number of iterations to apply the mouse force over."})]})]})]})}),Object(j.jsx)(c.a,{children:Object(j.jsx)("p",{children:"The following are some results that we recieved from our implementation. We ran at 4000 particles at 12-15fps. This is very close to the particle count of 5000 mentioned in the paper with a stable fps"})}),Object(j.jsxs)(c.a,{children:[Object(j.jsx)(d.a,{url:"https://youtu.be/-6NWf9phIio"}),Object(j.jsx)(d.a,{url:"https://youtu.be/ssmsc0edW8E"})]}),Object(j.jsx)("br",{}),Object(j.jsx)("br",{}),Object(j.jsxs)(c.a,{children:[Object(j.jsx)(d.a,{url:"https://youtu.be/2OVFJwOe9lU"}),Object(j.jsx)(d.a,{url:"https://www.youtube.com/watch?v=Ve3xhCWj_q8"})]})]})]})},u=function(e){e&&e instanceof Function&&r.e(3).then(r.bind(null,54)).then((function(t){var r=t.getCLS,i=t.getFID,a=t.getFCP,s=t.getLCP,n=t.getTTFB;r(e),i(e),a(e),s(e),n(e)}))};r(50),r(51);n.a.render(Object(j.jsx)(a.a.StrictMode,{children:Object(j.jsx)(m,{})}),document.getElementById("root")),u()}},[[52,1,2]]]);
//# sourceMappingURL=main.484bb3ca.chunk.js.map
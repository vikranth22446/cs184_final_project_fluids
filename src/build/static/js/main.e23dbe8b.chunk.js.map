{"version":3,"sources":["index.js"],"names":["w_poly","r","h","Math","PI","pow","w_poly_derivative6","w_poly_laplacian","laplace_viscosity","w_spiky_derivative","vvadd","v1","v2","THREE","x","y","z","vmuls","s","dist","pos1","pos2","sqrt","Swarm","count","mesh","useRef","useState","dummy","viewport","useThree","particles","useMemo","temp","i","t","random","xFactor","yFactor","zFactor","pos","force","vel","mass","push","useFrame","state","clock","forEach","particle","density","p","other_particle","density_s","pressure_force","f_p_x","f_p_y","f_p_z","pi","pj","pressure","n_x","n_y","n_z","compute_pressure","viscosity_force","f_v_x","f_v_y","f_v_z","mu","viscosity_x","viscosity_y","compute_viscosity","gravity_force","compute_gravity","surface_tension","f_t_x","f_t_y","f_t_z","c_x","c_y","c_z","k","sigma","compute_surface_tension","factor","speed","particle_mass","delta_t","next_acc","reduce","acc","item","index","new_vel","new_pos","height","position","set","scale","updateMatrix","current","setMatrixAt","matrix","instanceMatrix","needsUpdate","ref","args","roughness","color","Stats","StatsImpl","stats","useEffect","showPanel","document","body","appendChild","dom","removeChild","begin","gl","render","scene","camera","end","Plane","props","usePlane","Borders","rotation","width","App","attach","powerPreference","intensity","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.e23dbe8b.chunk.js","sourcesContent":["import * as THREE from 'three'\nimport ReactDOM from 'react-dom'\nimport React, { useRef, useMemo, useState, Suspense, useEffect } from 'react'\nimport { Canvas, useFrame, useThree,addTail } from '@react-three/fiber'\nimport StatsImpl from \"stats.js\"\nimport { Environment, ContactShadows } from '@react-three/drei'\nimport { EffectComposer, SSAO } from '@react-three/postprocessing'\nimport './styles.css'\nimport { Physics, useBox, useSphere, usePlane } from '@react-three/cannon'\nimport throttle from \"lodash/throttle\"\n\nfunction w_poly(r, h) {\n    if(r > h || r < 0 ) return 0;\n    return 315/(64*Math.PI * Math.pow(h, 9)) * Math.pow((Math.pow(h, 2) - Math.pow(r, 2)), 3); \n}\n\nfunction w_poly_derivative6(r, h) {\n    if(r > h || r < 0 ) return 0;\n    return 315/(64*Math.PI * Math.pow(h, 9)) * 3 * Math.pow((Math.pow(h, 2) - Math.pow(r, 2)), 2) * (-2 * r); \n}\nfunction w_poly_laplacian(r, h) {\n  if(r > h || r < 0 ) return 0;\n  return 315/(64*Math.PI * Math.pow(h, 9)) * 3 * Math.pow((Math.pow(h, 2) - Math.pow(r, 2)), 2) * (-2) + 315/(64*Math.PI * Math.pow(h, 9)) * 6 * Math.pow((Math.pow(h, 2) - Math.pow(r, 2)), 1) * (-2 * r); \n}\n\nfunction w_viscosity(r, h) {\n  if (r > h || r < 0) return 0; \n  return 15/(2 * Math.PI * pow(h, 3)) * (-pow(r, 3)/(2 * pow(h, 3))) * (pow(r, 2)/pow(h,2)) * h/(2*r) - 1; \n}\n\nfunction laplace_viscosity(r, h) {\n  if (r > h || r < 0) return 0; \n  return 45/(Math.PI * Math.pow(h, 6)) * (h-r)\n}\n\nfunction w_spiky(r, h) {\n    if (r > h || r < 0) return 0; \n    return 15/(Math.PI * pow(h, 6)) * pow((h - r), 3)\n}\nfunction w_spiky_derivative(r, h) {\n    if (r > h || r < 0) return 0; \n    return 15/(Math.PI * Math.pow(h, 6)) * 3 * Math.pow((h - r), 2) * (-1)\n}\n\nfunction density_s(particle, particles) {\n    // [x, y, z]\n    const h = 1;\n    var p = 0;\n    for(let other_particle of particles) {\n        const r = dist(other_particle.pos, particle.pos);\n        p += other_particle.mass * w_poly(r, h);\n    }    \n    particle.density = p;\n    return p;\n}\n\nfunction compute_pressure(particle, particles) {\n    var f_p_x = 0.0;\n    var f_p_y = 0.0;\n    var f_p_z = 0.0;\n    const k = 1; // speed of sound \n    const h = 1;\n    const rho_zero = 1;\n    const pi = k * (particle.density - rho_zero);\n\n    // for pressure using w_spiky_derivative kernel\n    for(let other_particle of particles) {\n        const pj = k * (other_particle.density - rho_zero);\n        const r = dist(other_particle.pos, particle.pos)\n\n        const pressure = -other_particle.mass*(pi + pj)/(2*other_particle.density)*w_spiky_derivative(r, h)\n        if(r != 0) {\n          const n_x = (particle.pos.x - other_particle.pos.x)/r\n          const n_y = (particle.pos.y - other_particle.pos.y)/r\n          const n_z = (particle.pos.z - other_particle.pos.z)/r\n          f_p_x += n_x * pressure\n          f_p_y += n_y * pressure\n          f_p_z += n_z * pressure\n        }\n\n    }\n\n    return new THREE.Vector3(f_p_x, f_p_y, f_p_z)\n}\n\nfunction compute_viscosity(particle, particles) {\n    var f_v_x = 0.0;\n    var f_v_y = 0.0;\n    var f_v_z = 0.0;\n    const h = 1;\n    const mu =  0.01; // viscosity of water at 20 degrees\n    for(let other_particle of particles) {\n        const r = dist(other_particle.pos, particle.pos)\n        const viscosity_x = -other_particle.mass*(other_particle.vel.x - particle.vel.x)/other_particle.density *laplace_viscosity(r, h)\n        const viscosity_y = -other_particle.mass*(other_particle.vel.y - particle.vel.y)/other_particle.density *laplace_viscosity(r, h)\n        const viscosity_z = -other_particle.mass*(other_particle.vel.z - particle.vel.z)/other_particle.density *laplace_viscosity(r, h)\n        f_v_x += viscosity_x\n        f_v_y += viscosity_y\n        f_v_z + viscosity_z\n    }\n    f_v_x *= mu;\n    f_v_y *= mu;\n    f_v_z *= mu;\n    return new THREE.Vector3(f_v_x, f_v_y, f_v_z)\n}\nfunction compute_gravity(particle, particles) {\n    const volume = 1;\n    const mass = particle.density * volume;\n    return new THREE.Vector3(0.0, -9.8 * mass, 0.0)\n}\nfunction compute_surface_tension(particle, particles) {\n    var f_t_x = 0.0;\n    var f_t_y = 0.0;\n    var f_t_z = 0.0;\n\n    var c_x = 0.0;\n    var c_y = 0.0;\n    var c_z = 0.0;\n\n    var k = 0.0;\n\n    // https://www.engineeringtoolbox.com/surface-tension-d_962.html\n    const sigma = 0.0728 / 10; // signam surface tension of water N/m at 20 degrees\n    const h = 1.0;\n    for(let other_particle of particles) {\n        const r = dist(particle.pos, other_particle.pos)\n        const surface_tension = other_particle.mass * 1/(other_particle.density) * w_poly_derivative6(r, h)\n        if(r != 0) {\n          const n_x = (particle.pos.x - other_particle.pos.x)/r\n          const n_y = (particle.pos.y - other_particle.pos.y)/r\n          const n_z = (particle.pos.z - other_particle.pos.z)/r\n          c_x += surface_tension * n_x;\n          c_y += surface_tension * n_y;\n          c_z += surface_tension * n_z;\n          k +=  other_particle.mass * 1/(other_particle.density) * w_poly_laplacian(r, h)/r\n      }\n    }\n\n    f_t_x = sigma * c_x * k;\n    f_t_y = sigma * c_y * k;\n    f_t_z = sigma * c_z * k;\n    return new THREE.Vector3(f_t_x, f_t_y, f_t_z)\n}\n\nfunction vvadd(v1, v2) {\n  return new THREE.Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)\n}\nfunction vmuls(v1, s) {\n  return new THREE.Vector3(v1.x * s, v1.y*s, v1.z*s)\n}\nfunction vvadd_multiple(vect) {\n  return vect.reduce((acc, item, index) => vvadd(acc, item))\n}\n\n\nfunction dist(pos1, pos2) {\n  return Math.sqrt(Math.pow((pos1.x - pos2.x), 2) + Math.pow((pos1.y - pos2.y), 2) + Math.pow((pos1.z - pos2.z), 2))\n}\n\nfunction Swarm({ count, ...props }) {\n  const mesh = useRef()\n  const [dummy] = useState(() => new THREE.Object3D())\n  var plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\n  const { viewport } = useThree();\n  const particles = useMemo(() => {\n    const temp = []\n    for (let i = 0; i < count; i++) {\n      const t = Math.random() * 100\n\n      const xFactor = 0 + (Math.random()-.5) * 4\n      const yFactor = -1 + (Math.random()-.5) * 1\n      const zFactor = 0 + (Math.random()-.5) * 1\n      const pos = new THREE.Vector3(xFactor, yFactor, zFactor)\n      const force = new THREE.Vector3(0, 0.0, 0);\n      // Note using implicit euler over verlet because it is more physically accurate\n      const vel = new THREE.Vector3(0.0,0)\n      const mass = .01;\n      temp.push({ t, pos:pos, force:force, mass:mass, vel: vel})\n    }\n    return temp\n  }, [count])\n\n  useFrame(({state, clock}) => {\n    particles.forEach((particle, i) => {\n        particle.density = density_s(particle, particles)\n    });\n    particles.forEach((particle, i) => {\n        particle.pressure_force = compute_pressure(particle, particles)\n    });\n    particles.forEach((particle, i) => {\n        particle.viscosity_force = compute_viscosity(particle, particles)\n    });\n    particles.forEach((particle, i) => {\n      particle.gravity_force = compute_gravity(particle, particles)\n    });\n    particles.forEach((particle, i) => {\n      particle.surface_tension = compute_surface_tension(particle, particles)\n    });\n\n\n    particles.forEach((particle, i) => {\n        let { t, factor, speed, pos, mass, vel } = particle\n        particle.t = t + 1\n        const particle_mass = 1 * particle.density\n        // t = particle.t += speed / 2\n        const delta_t = 1/60 * 8\n        const net_force = vvadd_multiple([particle.pressure_force, particle.viscosity_force, particle.gravity_force, particle.surface_tension])\n        const next_acc = vmuls(net_force, 1/particle_mass * delta_t * delta_t)\n        var new_vel = vvadd(vel, vmuls(next_acc, delta_t))\n        var new_pos = vvadd(pos, vmuls(new_vel, delta_t))\n        \n        // if it hits the bounding box, comes back with opposite velocity\n        if(new_pos.y < -viewport.height / 2 + 1) {\n          new_pos.y = -viewport.height / 2 + 1\n          new_vel.y *= -1\n        }\n        if(new_pos.y > 2) {\n          new_pos.y = 2\n          new_vel.y *= -1\n        }\n        if(new_pos.x < -2) {\n          new_pos.x = -2\n          new_vel.x *= -1\n        }\n        if(new_pos.x > 2) {\n          new_pos.x = 2\n          new_vel.x *= -1\n        }\n        if(new_pos.z < -2) {\n          new_pos.z = -2\n          new_vel.z *= -1\n        }\n        if(new_pos.z > 2) {\n          new_pos.z = 2\n          new_vel.z *= -1\n        }\n        // Update the dummy object\n        particle.pos = new_pos\n        particle.vel = new_vel\n        // handle hitting the bounds\n       \n\n        // temp = <x,y,z>\n        dummy.position.set(new_pos.x, new_pos.y, new_pos.z);\n        dummy.scale.set(1, 1, 1)\n        dummy.updateMatrix()\n        // \n        // And apply the matrix to the instanced item\n        mesh.current.setMatrixAt(i, dummy.matrix)\n      })\n    mesh.current.instanceMatrix.needsUpdate = true\n  })\n  const uniforms = {\n    k_a: { value: new THREE.Vector3(0.9, 0.5, 0.3) },\n    k_d: { value: new THREE.Vector3(0.9, 0.5, 0.3) },\n    k_s: { value: new THREE.Vector3(0.8, 0.8, 0.8) },\n    I_a: {value: new THREE.Vector3(1.0, 1.0, 1.0) },\n    LightIntensity: { value: new THREE.Vector4(0.5, 0.5, 0.5, 1.0) },\n    LightPosition: { value: new THREE.Vector4(0.0, 2000.0, 0.0, 1.0) },\n    p: {value: 100.0}\n  };\n  const vertexShader = `\n  varying vec3 Normal;\n  varying vec3 Position;\n  void main() {\n    Normal = normalize(normalMatrix * normal);\n    Position = vec3(modelViewMatrix * vec4(position, 1.0));\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n  `;\n  const defaultAttributeValues = {\n      'color': [ 1, 1, 1 ],\n      'uv': [ 0, 0 ],\n      'uv2': [ 0, 0 ]\n  }\n  const fragmentShader = `\n  varying vec3 Normal;\n  varying vec3 Position;\n  uniform vec3 k_a;\n  uniform vec3 k_s;\n  uniform float p;\n  uniform vec3 k_d;\n  uniform vec3 I_a;\n  uniform vec4 LightPosition;\n  uniform vec3 LightIntensity;\n  vec3 bp_shading() {\n  vec3 n = normalize(Normal);\n  vec3 s = normalize(vec3(LightPosition) - Position);\n  vec3 v = normalize(vec3(-Position));\n  vec3 h = normalize(s) + normalize(v);\n    return LightIntensity * (k_a + k_s * pow(max(dot(h, n),0.0), p) + k_d * max(dot(s, Normal), 0.0 ));\n}\nvoid main() {\n  gl_FragColor = vec4(bp_shading(), 1.0);\n}\n  `;\n  return (\n    <instancedMesh ref={mesh} args={[null, null, count]}>\n        <sphereBufferGeometry args={[.1, 5, 5]}/>\n        <meshStandardMaterial roughness={0} color=\"royalblue\" />\n        {/* <shaderMaterial\n        name=\"material\"\n        uniforms={uniforms}\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        defaultAttributeValues={defaultAttributeValues}\n      /> */}\n    </instancedMesh>\n  )\n}\n\n\nfunction Stats() {\n  const [stats] = useState(() => new StatsImpl())\n  useEffect(() => {\n    stats.showPanel(0)\n    document.body.appendChild(stats.dom)\n    return () => document.body.removeChild(stats.dom)\n  }, [])\n  return useFrame(state => {\n    stats.begin()\n    state.gl.render(state.scene, state.camera)\n    stats.end()\n  }, 1)\n}\n\n// A physical plane without visual representation\nfunction Plane({ color, ...props }) {\n  usePlane(() => ({ ...props }));\n  return null;\n}\nfunction Borders() {\n  const { viewport } = useThree();\n  return (\n    <>\n      <Plane\n        position={[0, -viewport.height / 2, 0]}\n        rotation={[-Math.PI / 2, 0, 0]}\n      />\n      <Plane\n        position={[-viewport.width / 2 - 1, 0, 0]}\n        rotation={[0, Math.PI / 2, 0]}\n      />\n      <Plane\n        position={[viewport.width / 2 + 1, 0, 0]}\n        rotation={[0, -Math.PI / 2, 0]}\n      />\n      <Plane position={[0, 0, 0]} rotation={[0, 0, 0]} />\n      <Plane position={[0, 0, 12]} rotation={[0, -Math.PI, 0]} />\n    </>\n  );\n}\n\nfunction RotatingBox() {\n    const myMesh = React.useRef();\n    const [active, setActive] = useState(false);\n    useFrame(({clock}) => {\n        const a = clock.getElapsedTime();\n        myMesh.current.rotation.x = Math.cos(clock.getElapsedTime());\n        myMesh.current.rotation.y = Math.sin(clock.getElapsedTime());\n        if(myMesh.current.position.y < -4) {\n            myMesh.current.sign_flip = true;\n        }  else if(myMesh.current.position.y > 4) {\n            myMesh.current.sign_flip = false;\n        }\n\n        if(myMesh.current.sign_flip) {\n            myMesh.current.position.y += 0.01\n        } else {\n            myMesh.current.position.y -= 0.01\n        }\n    });  \n    const uniforms = {\n      k_a: { value: new THREE.Vector3(0.9, 0.5, 0.3) },\n      k_d: { value: new THREE.Vector3(0.9, 0.5, 0.3) },\n      k_s: { value: new THREE.Vector3(0.8, 0.8, 0.8) },\n      I_a: {value: new THREE.Vector3(1.0, 1.0, 1.0) },\n      LightIntensity: { value: new THREE.Vector4(0.5, 0.5, 0.5, 1.0) },\n      LightPosition: { value: new THREE.Vector4(0.0, 2000.0, 0.0, 1.0) },\n      p: {value: 100.0}\n    };\n    const vertexShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n    void main() {\n      Normal = normalize(normalMatrix * normal);\n      Position = vec3(modelViewMatrix * vec4(position, 1.0));\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n    `;\n    const defaultAttributeValues = {\n      \t'color': [ 1, 1, 1 ],\n      \t'uv': [ 0, 0 ],\n      \t'uv2': [ 0, 0 ]\n    }\n    const fragmentShader = `\n    varying vec3 Normal;\n    varying vec3 Position;\n    uniform vec3 k_a;\n    uniform vec3 k_s;\n    uniform float p;\n    uniform vec3 k_d;\n    uniform vec3 I_a;\n    uniform vec4 LightPosition;\n    uniform vec3 LightIntensity;\n    vec3 bp_shading() {\n    vec3 n = normalize(Normal);\n    vec3 s = normalize(vec3(LightPosition) - Position);\n    vec3 v = normalize(vec3(-Position));\n    vec3 h = normalize(s) + normalize(v);\n      return LightIntensity * (k_a + k_s * pow(max(dot(h, n),0.0), p) + k_d * max(dot(s, Normal), 0.0 ));\n  }\n  void main() {\n    gl_FragColor = vec4(bp_shading(), 1.0);\n  }\n    `;\n    return <mesh\n      scale={active ? 1.5 : 1}\n      onClick={() => setActive(!active)}\n      ref={myMesh}\n    >\n      <sphereBufferGeometry />\n      {/* <meshPhongMaterial color=\"royalblue\" /> */}\n      <shaderMaterial\n        name=\"material\"\n        uniforms={uniforms}\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        defaultAttributeValues={defaultAttributeValues}\n      />\n    </mesh>\n}\n\nfunction App() {\n  return (\n    <>\n      <Canvas >\n        <color attach=\"background\" args={['#f0f0f0']} powerPreference={\"high-performance\"}/>\n        <ambientLight intensity={0.5} />\n\n        <directionalLight/>\n        {/* <Swarm count={5} position={[0, 10, 0]} /> */}\n        {/* <ContactShadows rotation={[Math.PI / 2, 0, 0]} position={[0, -30, 0]} opacity={0.4} width={100} height={100} blur={1} far={40} /> */}\n        {/* <EffectComposer multisampling={0}>\n          <SSAO samples={31} radius={10} intensity={20} luminanceInfluence={0.1} color=\"red\" />\n        </EffectComposer> */}\n        {/* <Suspense fallback={null}>\n          <Environment preset=\"city\" /> \n        </Suspense>  */}\n        <Physics>\n          <Borders></Borders>\n          <Swarm count={1000}/>\n        </Physics>\n        <Stats />\n        {/* <RotatingBox></RotatingBox> */}\n        {/* <Swarm /> */}\n      </Canvas>\n    </>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}